{"features":[
  {"id":"CMM-001","name":"config.py: MCP mesh + orchestrator + agent pool env vars","description":"Add to config.py: ORCHESTRATOR_ENABLED=false, MCP_MESH_ENABLED=false, AGENT_POOL_ENABLED=false, SPECIALIST_TOOLS_ENABLED=false, AGENT_POOL_MAX_CONCURRENCY=8, AGENT_POOL_ROLE_MAX=2, AGENT_POOL_WARM_TIMEOUT=60, ORCHESTRATOR_RESTART_DELAY=3, MCP_HEALTH_CHECK_INTERVAL=60, MCP_RESTART_MAX_ATTEMPTS=3, ACTP_MCP_PORT=8766, ACTP_MCP_AUTH_KEY env var","category":"setup","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-002","name":"requirements.txt: add MCP + FastAPI deps","description":"Add to requirements.txt: fastapi>=0.115.0, uvicorn>=0.32.0, mcp>=1.0.0 (or httpx-mcp), pydantic>=2.0.0. Pin versions. Keep backward compatible with existing deps.","category":"setup","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-003","name":"File skeleton: orchestrator_agent.py","description":"Create actp-worker/orchestrator_agent.py with class OrchestratorAgent, __init__, process(), warm_up(), shutdown(), status(). All methods raise NotImplementedError for now â€” stubs only. Add module-level logger and feature flag guard at top.","category":"setup","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-004","name":"File skeleton: agent_pool.py","description":"Create actp-worker/agent_pool.py with dataclasses SpecialistHandoff, SpecialistResult, AgentHandle, AgentPoolStatus. Class AgentPool with acquire(), release(), run_task(), status() stubs. Module-level POOL singleton. Feature flag guard.","category":"setup","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-005","name":"File skeleton: mcp_service_mesh.py","description":"Create actp-worker/mcp_service_mesh.py with dataclass MCPServerHandle, MCPServerConfig. Class MCPServiceMesh with start_all(), get(), health_check(), restart(), stop_all() stubs. Module-level MESH singleton. Feature flag guard.","category":"setup","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-006","name":"File skeleton: actp_mcp_server.py","description":"Create actp-worker/actp_mcp_server.py as a FastAPI app on ACTP_MCP_PORT (8766). Skeleton routes: GET /health, GET /tools (list all). Auth: Bearer ACTP_MCP_AUTH_KEY. All tool endpoints return 501 Not Implemented stubs. Runnable via uvicorn.","category":"setup","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-007","name":"specialist_tools/ package scaffold","description":"Create actp-worker/specialist_tools/__init__.py exporting ToolResult dataclass (tool_name, success, data, error, duration_ms). Create empty files: researcher_tools.py, content_tools.py, acquisition_tools.py, publisher_tools.py, watchdog_tools.py. Each with module docstring and logger.","category":"setup","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-008","name":"specialist_souls/ directory with 6 soul files","description":"Create actp-worker/specialist_souls/ with: researcher-soul.md, coding-soul.md, content-soul.md, acquisition-soul.md, publisher-soul.md, watchdog-soul.md. Each defines: role identity, domain scope, output format, tool list, constraints, example task. Based on AGENT_PROFILES in agent_swarm.py.","category":"setup","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-009","name":"mcp_servers.json: MCP server registry config file","description":"Create actp-worker/mcp_servers.json listing all 18 MCP servers with: name, type (local|external), host, port, health_endpoint, restart_policy (auto|never), roles (which specialist roles use it), required_env_vars. Matches PRD-051 Section 3.4 table.","category":"setup","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-010","name":"start_all.sh: MCP mesh + orchestrator startup section","description":"Add to start_all.sh: start actp_mcp_server on 8766 (if MCP_MESH_ENABLED), start orchestrator_agent (if ORCHESTRATOR_ENABLED), add both to status checks and stop command. PID files: .pids/actp_mcp_server.pid, .pids/orchestrator.pid.","category":"infra","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-011","name":"Supabase migration: actp_agent_pool_runs table","description":"CREATE TABLE actp_agent_pool_runs (id uuid PK, role text, task_id text, handoff_intent text, status text, started_at timestamptz, finished_at timestamptz, duration_ms int, result_summary text, error text, mcp_servers text[], skill_domain text). For auditing and latency tracking.","category":"database","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-012","name":"Supabase migration: actp_mcp_server_health table","description":"CREATE TABLE actp_mcp_server_health (id uuid PK, server_name text, status text, last_check timestamptz, consecutive_failures int, last_error text, latency_ms int, requests_total int, errors_total int). Upserted every health check cycle.","category":"database","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-013","name":"Supabase migration: actp_orchestrator_sessions table","description":"CREATE TABLE actp_orchestrator_sessions (id uuid PK, user_id bigint, session_start timestamptz, last_activity timestamptz, turn_count int, context jsonb, specialists_used text[]). One row per user, upserted on each turn.","category":"database","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-016","name":"Fix double-processing bug in telegram_command_bot.py","description":"Root cause: when ai_chat returns an empty/falsy reply (partial_failure), code falls through to agent-core two-layer path which also spawns the swarm. Fix: (1) if ai_reply is falsy but no exception, return a fallback string instead of falling through. (2) Add processed_update_ids set to deduplicate any replayed updates. Both fixes together eliminate double sends.","category":"bot","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-017","name":"telegram_command_bot.py: wire orchestrator path (feature-flagged)","description":"In handle_admin_message(), before the existing ai_chat block, check: if ORCHESTRATOR_ENABLED and orchestrator is available, call orchestrator.process(user_id, text). Return result directly. Else fall through to existing ai_chat path. Feature flag ensures zero behavior change when disabled.","category":"bot","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-018","name":"telegram_command_bot.py: fix on_progress duplicate sends","description":"Current on_receipt and on_progress both call _send(), causing multiple messages. Fix: on_receipt fires once (ack), on_progress fires for meaningful milestones only (not every 10% update). Add dedup: skip progress send if identical text was sent < 500ms ago.","category":"bot","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-019","name":"telegram_command_bot.py: /meshstatus slash command","description":"Add /meshstatus command: calls MCPServiceMesh.health_check() and AgentPool.status(). Returns formatted table: server name, status (online/offline/degraded), latency_ms, last_checked. Also shows active specialists. Graceful fallback if mesh not enabled.","category":"bot","priority":3,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-021","name":"mcp_service_mesh.py: MCPServerConfig + MCPServerHandle dataclasses","description":"MCPServerConfig: name, type (local|external), base_url, health_endpoint, restart_policy, restart_cmd, roles list, timeout_seconds. MCPServerHandle: config, process (Optional[subprocess.Popen]), status (online|offline|degraded), last_health_check, consecutive_failures, latency_ms.","category":"mcp","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-022","name":"mcp_service_mesh.py: MCPServiceMesh.start_all()","description":"Reads mcp_servers.json, instantiates MCPServerHandle per config. For local servers: starts subprocess, waits for health endpoint to respond (up to 10s). For external: pings health endpoint. Logs success/fail per server. Returns dict of nameâ†’status.","category":"mcp","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-023","name":"mcp_service_mesh.py: MCPServiceMesh.get(name)","description":"Returns MCPServerHandle for named server. Raises MCPServerNotFoundError if unknown. Raises MCPServerOfflineError if status is offline. Caller can catch and use HTTP fallback.","category":"mcp","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-024","name":"mcp_service_mesh.py: MCPServiceMesh.health_check()","description":"Async method: for each server, GET {health_endpoint}, measure latency. Update handle.status and handle.latency_ms. Increment consecutive_failures on timeout/error. Upsert to actp_mcp_server_health Supabase table. Returns dict[name, HealthResult].","category":"mcp","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-025","name":"mcp_service_mesh.py: MCPServiceMesh.restart(name)","description":"For local servers with restart_policy=auto: kill existing process, re-run restart_cmd, wait for health. Increment restart count. Log to Supabase. Raises if max restart attempts exceeded. For external servers: raise MCPRestartNotSupportedError.","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-026","name":"mcp_service_mesh.py: health check loop (background task)","description":"asyncio background task: every MCP_HEALTH_CHECK_INTERVAL seconds, call health_check(). Auto-restart any local server with consecutive_failures >= 3 and restart_policy=auto. Logs restarts to Supabase. Task starts with MCPServiceMesh.start_all().","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-027","name":"mcp_service_mesh.py: circuit breaker per server","description":"Each handle tracks: trip_count, tripped_at. Circuit trips after 3 consecutive failures. Tripped circuit: all get() calls for that server raise CircuitOpenError immediately (no retry). Circuit resets after 5 minutes. Prevents cascade failures.","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-028","name":"mcp_service_mesh.py: graceful HTTP fallback","description":"MCPServiceMesh.get_or_fallback(name) â†’ Union[MCPServerHandle, HTTPFallback]. If server is offline/tripped, returns HTTPFallback object with base_url. Caller checks type and uses appropriate client. Allows zero-downtime degradation for each service.","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-029","name":"mcp_service_mesh.py: register safari DM services","description":"In mcp_servers.json, register: safari-instagram-dm (3100/3001), safari-twitter-dm (3003), safari-tiktok-dm (3102), safari-linkedin (3105). Health endpoint: GET /health. Restart cmd: start script from start_all.sh. Roles: acquisition only.","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-030","name":"mcp_service_mesh.py: register safari comment + research services","description":"Register: safari-threads-comments (3004), safari-instagram-comments (3005), safari-tiktok-comments (3006), safari-twitter-comments (3007), market-research (3106), safari-gateway (7070). Health endpoints. Roles: researcher + content.","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-031","name":"mcp_service_mesh.py: register external Vercel services","description":"Register as external (restart_policy=never): workflow-engine (Vercel URL), contentlite (Vercel URL), researchlite (Vercel URL), publishlite (Vercel URL), metricslite (Vercel URL), blotato (backend.blotato.com). Health: GET /api/health. Roles per service.","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-041","name":"actp_mcp_server.py: FastAPI app with auth","description":"FastAPI app on ACTP_MCP_PORT. Middleware: validate Bearer ACTP_MCP_AUTH_KEY header (skip if key empty = localhost trust). GET /health returns {ok, version, tool_count}. GET /tools returns list of all registered tool definitions with name, description, parameters schema.","category":"mcp","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-042","name":"actp_mcp_server.py: tool create_job","description":"POST /tools/create_job body: {topic: str, params: dict, priority: str='normal'}. Dispatches to ACTP worker via existing job queue. Returns {job_id, status, created_at}. Validates topic exists in ACTP topic registry before dispatch.","category":"mcp","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-043","name":"actp_mcp_server.py: tools get_job + list_jobs","description":"GET /tools/get_job?job_id=X: returns full JobStatus including status, result, error, duration_ms, created_at, updated_at. GET /tools/list_jobs?status=X&limit=N: returns paginated list of jobs. Both read from Supabase actp_jobs table.","category":"mcp","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-044","name":"actp_mcp_server.py: tool wait_for_job","description":"POST /tools/wait_for_job body: {job_id: str, timeout: int=60}. Polls job status every 2s until done/failed/timeout. Returns JobResult with final status and result payload. Long-poll safe (uvicorn async).","category":"mcp","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-045","name":"actp_mcp_server.py: tool dispatch_topic","description":"POST /tools/dispatch_topic body: {topic: str, params: dict}. Creates job AND waits up to 30s for result (convenience wrapper over create_job + wait_for_job). Returns JobResult. This replaces the current dispatch_actp_topic HTTP call pattern.","category":"mcp","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-046","name":"actp_mcp_server.py: tool list_topics + get_topic_schema","description":"GET /tools/list_topics: returns list of all registered ACTP topic definitions (name, description, params schema, executor type). GET /tools/get_topic_schema?topic=X: returns full JSON schema for a specific topic's params. Reads from workflow_executors.py registry.","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-047","name":"actp_mcp_server.py: analytics tools","description":"GET /tools/get_revenue_summary?days=30: queries Supabase for revenue metrics. GET /tools/get_content_performance?platform=X&days=30: queries actp_published_content for performance. GET /tools/get_system_health: aggregates all service health. GET /tools/get_active_campaigns.","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-048","name":"actp_mcp_server.py: workflow tools","description":"GET /tools/get_workflow_status?slug=X: calls workflow-engine API, returns execution state + step states. POST /tools/start_workflow body: {slug, params}: starts a workflow execution. GET /tools/get_publish_queue?status=X: returns MPLite/PublishLite queue items.","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-049","name":"actp_mcp_server.py: swarm status tool","description":"GET /tools/get_swarm_status: calls agent_swarm.SwarmOrchestrator.status() and AgentPool.status(). Returns: active_specialists, queued_tasks, completed_today, failed_today, per-role breakdown. This is what /meshstatus Telegram command calls.","category":"mcp","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-050","name":"actp_mcp_server.py: unit tests","description":"tests/test_actp_mcp_server.py: test auth (valid key, missing key, empty key=pass). test create_job (valid topic, invalid topic). test get_job (found, not found). test list_jobs (filter by status). test dispatch_topic (mock wait). test health endpoint. 15+ test cases.","category":"testing","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-061","name":"skill_loader.py: SkillDomain enum + domain filtering","description":"Add SkillDomain enum: RESEARCH, CODING, CONTENT, ACQUISITION, PUBLISHING, WATCHDOG, ORCHESTRATOR. Extend get_registry(domain: SkillDomain | None = None): when domain specified, filter PRDs by domain frontmatter tags. Untagged PRDs only load for ORCHESTRATOR domain.","category":"skills","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-062","name":"skill_loader.py: PRD frontmatter parser","description":"Add _parse_prd_frontmatter(path) â†’ dict: reads YAML frontmatter block (---...---) from PRD .md files. Extracts: domain list, agent_roles list, priority (high/medium/low). Returns empty dict if no frontmatter. Cache results per file (mtime-based invalidation).","category":"skills","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-063","name":"Tag research PRDs with domain frontmatter","description":"Add frontmatter to: PRD-003-SAFARI-RESEARCH-PIPELINE.md, PRD-008-AUTONOMOUS-TWITTER-RESEARCH-PIPELINE.md, PRD-003-SAFARI-RESEARCH-PIPELINE.md, and any market/analytics PRDs in harness/prompts/ and actp-worker/. domain: [research], agent_roles: [researcher].","category":"skills","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-064","name":"Tag coding/ACD PRDs with domain frontmatter","description":"Add frontmatter to ACD-related PRDs, harness PRDs, testing PRDs, deployment PRDs. domain: [coding], agent_roles: [coding]. Includes AGENT_HARNESS_GUIDE.md, PRD-001-WORKFLOW-ENGINE.md coding sections, all ACD dispatch docs.","category":"skills","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-065","name":"Tag content PRDs with domain frontmatter","description":"Add frontmatter to content generation, video, publishing workflow, Remotion, Blotato PRDs. domain: [content], agent_roles: [content]. Includes PRD-007-RESEARCH-TO-BLOTATO-PIPELINE.md, ContentLite PRDs, video rendering PRDs.","category":"skills","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-066","name":"Tag acquisition PRDs with domain frontmatter","description":"Add frontmatter to DM, CRM, LinkedIn, Upwork, outreach, lead gen PRDs. domain: [acquisition], agent_roles: [acquisition]. Includes PRD-022 through PRD-028 acquisition series, crm_brain docs.","category":"skills","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-067","name":"Tag publishing/timing PRDs with domain frontmatter","description":"Add frontmatter to publishing, scheduling, MPLite, PublishLite, platform timing PRDs. domain: [publishing], agent_roles: [publisher]. Includes Thompson Sampling timing PRDs, MPLite integration docs.","category":"skills","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-068","name":"Tag watchdog/infra PRDs with domain frontmatter","description":"Add frontmatter to infrastructure, health monitoring, deployment, self-healing PRDs. domain: [watchdog], agent_roles: [watchdog]. Includes PRD-002-LOCAL-AGENT-DAEMON, start_all.sh docs, self-healing docs.","category":"skills","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-069","name":"skill_loader.py: domain audit + PRD count assertion","description":"Add skill_loader.audit_domains() â†’ dict: returns per-domain PRD count and list. Add assertion in tests: each specialist domain loads < 30 PRDs. Log WARNING if a domain loads > 30. Log INFO with domain breakdown on startup.","category":"skills","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-070","name":"skill_loader.py: domain-filtered system prompt builder","description":"Add build_system_prompt(role, soul_file, domain) â†’ str: loads soul file content + get_registry(domain) PRDs. Formats as system prompt: [SOUL] + [SKILLS: domain X] section with filtered PRD summaries. Used by AgentPool when spawning specialists.","category":"skills","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-071","name":"skill_loader.py: unit tests for domain filtering","description":"tests/test_skill_loader_domains.py: test_research_domain_loads_research_prds_only, test_coding_domain_excludes_acquisition_prds, test_orchestrator_domain_loads_all, test_untagged_prds_not_in_specialist_domains, test_domain_count_under_30. Mock filesystem for fast tests.","category":"testing","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-076","name":"agent_pool.py: SpecialistHandoff + SpecialistResult dataclasses","description":"SpecialistHandoff: role, intent, context (dict), mcp_servers (list[str]), skill_domain (str), tools_allowed (list[str]), priority ('normal'|'high'|'urgent'), timeout_seconds, on_progress (Callable|None). SpecialistResult: role, success, output (str), data (dict), duration_ms, error (str|None), tools_used (list[str]).","category":"agent_pool","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-077","name":"agent_pool.py: AgentHandle + AgentPoolStatus dataclasses","description":"AgentHandle: handle_id (uuid), role, pid (int|None), process (subprocess.Popen|None), started_at, handoff (SpecialistHandoff), status ('spawning'|'running'|'finishing'|'done'|'failed'). AgentPoolStatus: role, active_count, queued_count, max_count, completed_today, failed_today, avg_duration_ms.","category":"agent_pool","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-078","name":"agent_pool.py: AgentPool class with concurrency control","description":"AgentPool.__init__: _active: dict[str, list[AgentHandle]], _semaphores: dict[str, asyncio.Semaphore] per role, _total_semaphore: asyncio.Semaphore(AGENT_POOL_MAX_CONCURRENCY). _role_configs: dict with timeout, max per role. _completed: deque(maxlen=100) for metrics.","category":"agent_pool","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-079","name":"agent_pool.py: AgentPool.run_task() â€” full lifecycle","description":"async run_task(role, handoff) â†’ SpecialistResult: (1) acquire role semaphore + total semaphore, (2) build system prompt via skill_loader.build_system_prompt(role, domain), (3) spawn Claude Code subprocess with --system-prompt and MCP config flags, (4) stream stdout as on_progress callbacks, (5) parse final JSON result from stdout, (6) kill subprocess in finally, (7) release semaphores, (8) log to actp_agent_pool_runs.","category":"agent_pool","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-080","name":"agent_pool.py: specialist subprocess spawn with MCP config","description":"Specialist Claude Code invocation: claude --print --output-format json --system-prompt {soul_path} --mcp-config {mcp_config_path} -- '{intent}'. Generate temp mcp_config.json per spawn with only the allowed MCP servers for that role (from mcp_servers.json filtered by role). Pass tools_allowed as context in the prompt.","category":"agent_pool","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-081","name":"agent_pool.py: structured result parsing from subprocess","description":"Specialist subprocess must output a final JSON line: {success, output, data, tools_used}. AgentPool reads stdout line by line: lines matching progress pattern â†’ on_progress callback, final JSON line â†’ SpecialistResult. Handle malformed output gracefully (fallback to raw stdout as output).","category":"agent_pool","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-082","name":"agent_pool.py: warm reuse of specialist processes","description":"After task completion, keep process in _warm dict for AGENT_POOL_WARM_TIMEOUT seconds. If new task for same role arrives within timeout, send new task via stdin instead of spawning fresh process. Halves latency for follow-up queries. Fall back to fresh spawn if warm process dies.","category":"agent_pool","priority":3,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-083","name":"agent_pool.py: pool metrics + status()","description":"AgentPool.status() â†’ dict[str, AgentPoolStatus]: per role: active_count, queued_count, max_count, completed_today (reset at midnight), failed_today, avg_duration_ms (last 20 runs). Also: total_active, total_queued, total_completed_today. Exposed via actp_mcp_server /tools/get_swarm_status.","category":"agent_pool","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-084","name":"agent_pool.py: feature flag guard + SwarmAgent fallback","description":"If AGENT_POOL_ENABLED=false, AgentPool.run_task() delegates to existing SwarmAgent.run_task() from agent_swarm.py. Zero behavior change when disabled. AgentPool is always instantiated (for status calls) but routes through legacy path.","category":"agent_pool","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-085","name":"agent_pool.py: timeout enforcement + cleanup","description":"asyncio.wait_for(specialist_coroutine, timeout=handoff.timeout_seconds). On timeout: kill subprocess, log timeout to actp_agent_pool_runs, return SpecialistResult(success=False, error='timeout_{role}_{timeout}s'). Ensure semaphores are always released even on timeout.","category":"agent_pool","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-086","name":"agent_pool.py: unit tests","description":"tests/test_agent_pool.py: test_acquire_release_lifecycle (mock subprocess), test_concurrency_limit_blocks (semaphore), test_timeout_kills_subprocess, test_feature_flag_falls_back_to_swarm, test_status_returns_correct_counts, test_structured_result_parsing. Use pytest-asyncio.","category":"testing","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-101","name":"specialist_tools/researcher_tools.py: get_youtube_stats","description":"async get_youtube_stats(handle_or_url: str) â†’ ToolResult: calls MetricsLite /api/youtube/stats endpoint (METRICSLITE_URL from config). Returns ToolResult with data: {subscribers, views_30d, videos_count, top_video: {title, views, url}, channel_url}. Falls back to Blotato account data if MetricsLite unavailable.","category":"tools","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-102","name":"specialist_tools/researcher_tools.py: get_platform_metrics","description":"async get_platform_metrics(platform: str, account: str) â†’ ToolResult: dispatches to appropriate metrics source. TikTok/Instagram â†’ Safari market-research (3106). YouTube â†’ MetricsLite. Twitter â†’ actp_twitter_research Supabase table. Returns unified PlatformMetrics: {platform, account, followers, posts_30d, avg_engagement, top_posts}.","category":"tools","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-103","name":"specialist_tools/researcher_tools.py: safari_research tools","description":"async safari_twitter_research(keyword: str, count: int=50) â†’ ToolResult: POST to market-research (3106) /api/research/twitter/search. async safari_tiktok_research(keyword, count) â†’ same for tiktok. async safari_instagram_research(keyword, count) â†’ instagram. Returns list of posts with engagement data.","category":"tools","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-104","name":"specialist_tools/researcher_tools.py: get_top_creators + query_research_db","description":"async get_top_creators(niche: str, platform: str, limit: int=10) â†’ ToolResult: POST /api/research/{platform}/niche to market-research service. async query_research_db(table: str, filters: dict, limit: int=20) â†’ ToolResult: safe read-only Supabase query (whitelist of allowed tables: actp_platform_research, actp_platform_creators, actp_twitter_research).","category":"tools","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-105","name":"specialist_tools/content_tools.py: generate_content_from_blueprint","description":"async generate_content_from_blueprint(blueprint_id: str, platform: str, variant_count: int=3) â†’ ToolResult: POST to ContentLite (CONTENTLITE_URL) /api/generate/from-blueprint. Returns ContentResult with scripts list, hooks list, CTAs. Reads CONTENTLITE_URL from config.","category":"tools","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-106","name":"specialist_tools/content_tools.py: render_video + get_blueprints","description":"async render_video(template: str, params: dict) â†’ ToolResult: dispatches remotion_render local_task via ACTP worker. Polls for completion up to 120s. Returns {video_path, duration_s, size_mb}. async get_blueprints(niche: str='', limit: int=5) â†’ ToolResult: queries actp_platform_research Supabase for blueprint data.","category":"tools","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-107","name":"specialist_tools/content_tools.py: content queue + workflow tools","description":"async get_content_queue(status: str='pending', limit: int=10) â†’ ToolResult: reads actp_jobs Supabase for content-related jobs. async start_workflow(slug: str, params: dict) â†’ ToolResult: POSTs to workflow-engine /api/workflows/{slug}/run. async get_workflow_result(execution_id: str) â†’ ToolResult: GET /api/workflows/executions/{id}.","category":"tools","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-108","name":"specialist_tools/acquisition_tools.py: send_dm","description":"async send_dm(platform: str, username: str, message: str) â†’ ToolResult: routes to appropriate safari DM service (PLATFORM_PORT_MAP: instagramâ†’3100, twitterâ†’3003, tiktokâ†’3102, linkedinâ†’3105). POST /api/{platform}/dm with {username, message}. Returns {success, verified, strategy, rate_limits}.","category":"tools","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-109","name":"specialist_tools/acquisition_tools.py: CRM + prospect tools","description":"async get_dm_conversations(platform: str) â†’ ToolResult: GET /api/{platform}/conversations from DM service. async search_prospects(niche: str, platform: str, limit: int=20) â†’ ToolResult: POST /api/research/{platform}/search to market-research. async add_crm_contact(data: dict) â†’ ToolResult: upsert to crm_contacts Supabase. async get_crm_pipeline() â†’ ToolResult: aggregate crm_contacts by stage.","category":"tools","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-110","name":"specialist_tools/publisher_tools.py: timing + enqueue","description":"async get_best_publish_time(platform: str) â†’ ToolResult: GET PublishLite /api/timing?platform=X for Thompson Sampling optimal time. async enqueue_post(platform: str, content: str, media_path: str|None=None, scheduled_time: str|None=None) â†’ ToolResult: POST MPLite /api/actp/mplite/enqueue. Returns {queue_id, estimated_publish_time}.","category":"tools","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-111","name":"specialist_tools/publisher_tools.py: queue management + performance","description":"async get_publish_queue(status: str='pending') â†’ ToolResult: GET MPLite /api/actp/mplite/queue. async publish_now(post_id: str) â†’ ToolResult: claim + trigger immediate publish via MPLite. async get_post_performance(post_id: str) â†’ ToolResult: reads actp_published_content Supabase for metrics (views, likes, comments, shares).","category":"tools","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-112","name":"specialist_tools/watchdog_tools.py: service health tools","description":"async check_service_health(service_name: str) â†’ ToolResult: GET {service_url}/health (uses mcp_servers.json for URL lookup). async check_all_services() â†’ ToolResult: calls health_check() on all services in MCPServiceMesh, returns dict of nameâ†’{status, latency_ms}. async get_swarm_status() â†’ ToolResult: calls AgentPool.status() + agent_swarm status.","category":"tools","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-113","name":"specialist_tools/watchdog_tools.py: restart + logs tools","description":"async restart_service(service_name: str) â†’ ToolResult: calls MCPServiceMesh.restart(name). async get_error_logs(service: str, minutes: int=60) â†’ ToolResult: reads log files (LOGS_DIR from config) or Supabase error tables. async get_job_queue_stats() â†’ ToolResult: Supabase actp_jobs grouped by status + age buckets.","category":"tools","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-114","name":"specialist_tools: tool registry + execution wrapper","description":"specialist_tools/__init__.py: TOOL_REGISTRY: dict[role, list[ToolDefinition]]. register_tools(role: str) â†’ list[ToolDefinition]. Each tool wrapped with: timeout enforcement (asyncio.wait_for), error catch â†’ ToolResult(success=False, error=...), duration_ms measurement. Tools discoverable by orchestrator for handoff tool_allowed list.","category":"tools","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-115","name":"MetricsLite: POST /api/youtube/stats endpoint","description":"In metricslite (Vercel), add /api/youtube/stats route: accepts {handle_or_url: string}. Uses YouTube Data API v3 (YOUTUBE_API_KEY env) to fetch channel stats: subscriber_count, view_count, video_count, recent_videos (last 10). Falls back to public scrape if no API key. Returns unified response.","category":"tools","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-116","name":"MetricsLite: POST /api/platform/summary endpoint","description":"Add /api/platform/summary: accepts {platforms: string[], account_ids: dict}. Aggregates metrics from all configured platforms. YouTube via Data API, Instagram/TikTok via Blotato account stats, Twitter via actp_twitter_research Supabase table. Returns cross-platform summary with totals.","category":"tools","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-136","name":"orchestrator_agent.py: OrchestratorAgent class","description":"Class OrchestratorAgent: __init__(pool: AgentPool, mesh: MCPServiceMesh, skill_loader). _conversations: dict[int, list[dict]] for user context. warm_up(): pre-connects MCP mesh, loads all skills. process(user_id, text, on_receipt, on_progress) â†’ str. shutdown(): persists conversations. pid_file management for start_all.sh.","category":"orchestrator","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-137","name":"orchestrator_agent.py: intent classification","description":"_classify_intent(text) â†’ IntentClass enum: ANALYTICS_QUERY (stats/metrics/performance), CONTENT_REQUEST (generate/write/create), TASK_REQUEST (publish/schedule/dm/send), STATUS_QUERY (health/status/check), MULTI_STEP (compound task with multiple verbs), CONVERSATION (greeting/question). Used to decide dispatch strategy.","category":"orchestrator","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-138","name":"orchestrator_agent.py: single-specialist dispatch","description":"For ANALYTICS_QUERY, CONTENT_REQUEST, TASK_REQUEST, STATUS_QUERY: _build_handoff(intent_class, text, context) â†’ SpecialistHandoff. Maps intent_class to role, injects ACTP state from MCP as context, sets appropriate mcp_servers + skill_domain + tools_allowed. Calls pool.run_task(role, handoff) â†’ SpecialistResult.","category":"orchestrator","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-139","name":"orchestrator_agent.py: multi-step task decomposition","description":"For MULTI_STEP: _decompose_task(text) â†’ list[SpecialistHandoff] using Claude API call to decompose into ordered steps. Execute steps sequentially: each step's SpecialistResult.data injected into next step's context. Max 5 steps per decomposition. Timeout: sum of per-step timeouts.","category":"orchestrator","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-140","name":"orchestrator_agent.py: parallel dispatch for independent steps","description":"_decompose_task() annotates each step with depends_on: list[step_id]. Steps with no dependencies dispatched concurrently via asyncio.gather(). Dependent steps wait for their dependencies. Example: research + health_check can run in parallel; content_generation depends on research.","category":"orchestrator","priority":3,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-141","name":"orchestrator_agent.py: result synthesis","description":"_synthesize_results(intent, results: list[SpecialistResult]) â†’ str: calls Claude API with: original intent + all specialist outputs. Prompt: 'Synthesize these specialist results into a single coherent Telegram reply. Be concise. Use markdown.' Max output: 3000 chars. Handles single result (pass-through) and multi-result (synthesis).","category":"orchestrator","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-142","name":"orchestrator_agent.py: conversation context per user","description":"_get_context(user_id) â†’ dict: last 5 turns for user, last known ACTP state (platform, account, active_campaign). Persisted to actp_orchestrator_sessions Supabase. _update_context(user_id, turn, result): upserts. Context injected into every SpecialistHandoff so specialists know who they're working for.","category":"orchestrator","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-143","name":"orchestrator_agent.py: CONVERSATION passthrough","description":"For CONVERSATION intent (greetings, simple questions not requiring tools): skip AgentPool entirely. Call Claude API directly with orchestrator system prompt. Fast path: < 3s response. Prevents spawning a specialist for 'hello' or 'what can you do?'.","category":"orchestrator","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-144","name":"orchestrator_agent.py: ACTP state enrichment from MCP","description":"Before any dispatch: _enrich_context(): calls actp_mcp_server /tools/get_system_health (cached 30s), /tools/get_active_campaigns (cached 60s). Injects into context: {health_summary, active_campaigns, publish_queue_size, job_queue_size}. Orchestrator can reference live state in decomposition.","category":"orchestrator","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-145","name":"orchestrator_agent.py: self-healing restart via PID file","description":"OrchestratorAgent.run_forever(): asyncio event loop + signal handlers (SIGTERM, SIGINT). Write PID to .pids/orchestrator.pid on start, delete on clean shutdown. start_all.sh monitors this PID and restarts if missing (within ORCHESTRATOR_RESTART_DELAY=3s). Log restart count to Supabase.","category":"orchestrator","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-146","name":"orchestrator_agent.py: feature flag + fallback","description":"OrchestratorAgent.process(): if ORCHESTRATOR_ENABLED=false, raise OrchestratorDisabledError immediately. telegram_command_bot catches this and falls through to existing ai_chat path. This ensures zero behavior change when flag is off and enables safe A/B rollout.","category":"orchestrator","priority":1,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-147","name":"orchestrator_agent.py: latency budget tracking","description":"_track_latency(user_id, step, ms): records timing for each phase: classification, context_enrichment, handoff_build, specialist_run (per role), synthesis, total. Log WARNING if total > 30s. Log DEBUG breakdown for every request. Stored in actp_orchestrator_sessions.context['timing'].","category":"orchestrator","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-148","name":"orchestrator_agent.py: unit tests","description":"tests/test_orchestrator_agent.py: test_classify_intent_analytics, test_classify_intent_multistep, test_classify_intent_conversation, test_single_specialist_dispatch (mock pool), test_conversation_passthrough_skips_pool, test_context_enrichment, test_feature_flag_raises. 15+ test cases.","category":"testing","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-149","name":"orchestrator_agent.py: E2E test â€” YouTube stats","description":"tests/test_orchestrator_e2e.py: test_youtube_stats_end_to_end(): send 'Can we check YouTube stats?' through full stack (orchestrator â†’ researcher pool â†’ researcher_tools.get_youtube_stats â†’ MetricsLite). Assert SpecialistResult.success=True, data contains 'subscribers'. Mark @pytest.mark.e2e @pytest.mark.slow.","category":"testing","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-150","name":"orchestrator_agent.py: E2E test â€” multi-step research-generate-schedule","description":"tests/test_orchestrator_e2e.py: test_multistep_research_generate_schedule(): 'Research trending AI automation hooks, generate 3 TikTok scripts, schedule them for this week'. Assert 3 SpecialistHandoffs created (researcher, content, publisher), all succeed, final reply contains scheduled times. Mark @pytest.mark.e2e.","category":"testing","priority":3,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-161","name":"telegram_command_bot.py: /meshstatus full implementation","description":"Full /meshstatus: calls MCPServiceMesh.health_check() + AgentPool.status(). Formats as markdown table: ðŸŸ¢/ðŸŸ¡/ðŸ”´ per server, latency_ms. Shows active specialists (role + task + duration). Shows pool stats: completed today, failed today per role. Graceful if mesh not initialized (ORCHESTRATOR_ENABLED=false).","category":"bot","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-162","name":"telegram_command_bot.py: /specialize <role> <task> command","description":"Add /specialize command: directly spawns a named specialist without going through orchestrator. Usage: /specialize researcher 'what are the top TikTok hooks for AI automation?'. Shows progress via on_progress callbacks. Good for testing individual specialists. Admin-only.","category":"bot","priority":3,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-163","name":"agent_swarm.py: integrate AgentPool into SwarmOrchestrator","description":"SwarmOrchestrator.route_and_dispatch(): if AGENT_POOL_ENABLED and pool is available, route through AgentPool.run_task(). Else use existing SwarmAgent.run_task(). TaskRouter still decides the role â€” AgentPool just replaces the spawn mechanism. Backward compatible.","category":"agent_pool","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-164","name":"specialist soul files: researcher-soul.md","description":"Create actp-worker/specialist_souls/researcher-soul.md: Role: ResearchClaw - Platform Intelligence Analyst. Domain: market research, competitive analysis, platform metrics, creator discovery. Tools available (list all researcher_tools functions with descriptions). Output format: structured JSON with sources + data points. Constraints: never fabricate metrics, always cite source.","category":"skills","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-165","name":"specialist soul files: content + acquisition + publisher + watchdog","description":"Create: content-soul.md (ContentClaw - Creative Director), acquisition-soul.md (AcquisitionClaw - Growth Specialist), publisher-soul.md (PublisherClaw - Distribution Strategist), watchdog-soul.md (WatchdogClaw - Infrastructure Guardian). Each: role identity, domain, tools list, output format, constraints.","category":"skills","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-171","name":"Comprehensive E2E test suite: test_clawbot_mcp_mesh.py","description":"tests/test_clawbot_mcp_mesh.py covering: (1) routing tests â€” 6 messages each routing to correct specialist, (2) bot fix â€” zero double processing of same update_id, (3) agent pool â€” lifecycle spawn/run/kill, (4) MCP mesh health â€” all registered servers reachable, (5) skill domain â€” each specialist loads correct PRD subset. Pytest markers: mcp, orchestrator, specialist, bot.","category":"testing","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-172","name":"start_all.sh: full MCP mesh integration","description":"Add to start_all.sh: MCP_MESH section â€” start actp_mcp_server.py (uvicorn, port 8766) if MCP_MESH_ENABLED=true. Wait for /health. Add to status(): show actp_mcp_server status + port. Add to stop(): kill PID. Orchestrator section: start orchestrator_agent.py if ORCHESTRATOR_ENABLED=true.","category":"infra","priority":2,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-173","name":"docs: CLAWBOT_MESH_GUIDE.md","description":"Create actp-worker/docs/CLAWBOT_MESH_GUIDE.md: (1) Architecture diagram (ASCII), (2) Quick start: enable phase by phase with env vars, (3) Adding a new specialist role, (4) Adding a new MCP server, (5) Adding a new tool, (6) Troubleshooting: partial_failure, double processing, MCP server offline, pool exhaustion. Primary dev reference.","category":"setup","priority":3,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-174","name":"GitHub Actions CI: test MCP mesh in CI","description":"Update .github/workflows or create .github/workflows/clawbot-mesh.yml: run pytest tests/test_clawbot_mcp_mesh.py -m 'not e2e and not slow'. Mock all external HTTP calls (httpx mock). Run on push to main + PRs touching actp-worker/. Fail fast on double-processing regression.","category":"infra","priority":3,"status":"pending","prd":"PRD-051"},
  {"id":"CMM-175","name":"actp-worker: commit + push all new files","description":"git add all new files (orchestrator_agent.py, agent_pool.py, mcp_service_mesh.py, actp_mcp_server.py, specialist_tools/, specialist_souls/, mcp_servers.json). git commit -m 'feat: PRD-051 ClawBot MCP Agent Mesh â€” Phase 1+2 foundation'. git push origin main. Verify CI passes.","category":"infra","priority":3,"status":"pending","prd":"PRD-051"}
]}
